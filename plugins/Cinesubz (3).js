const axios = require('axios');

const cheerio = require('cheerio');

const { cmd } = require("../command");

const headers = {

  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',

  'Accept-Language': 'en-US,en;q=0.9',

  'Referer': 'https://google.com',

};

async function getMovieDetailsAndDownloadLinks(query) {

  try {

    const response = await axios.get(`https://cinesubz.co/?s=${encodeURIComponent(query)}`, { headers, maxRedirects: 5 });

    const html = response.data;

    const $ = cheerio.load(html);

    const films = [];

    $('article').each((i, element) => {

      const filmName = $(element).find('.details .title a').text().trim();

      const imageUrl = $(element).find('.image .thumbnail img').attr('src');

      const description = $(element).find('.details .contenido p').text().trim();

      const year = $(element).find('.details .meta .year').text().trim();

      const imdbText = $(element).find('.details .meta .rating:first').text().trim();

      const imdb = imdbText.replace('IMDb', '').trim();

      const movieLink = $(element).find('.image .thumbnail a').attr('href');

      films.push({ filmName, imageUrl, description, year, imdb, movieLink });

    });

    for (const film of films) {

      if (!film.movieLink) continue;

      const moviePageResponse = await axios.get(film.movieLink, { headers, maxRedirects: 5 });

      const moviePageHtml = moviePageResponse.data;

      const $$ = cheerio.load(moviePageHtml);

      const downloadLinks = [];

      // Download links scrape ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è <div class="download-links"> ‡∂∫‡∂± class ‡∂ë‡∂ö ‡∂á‡∂≠‡∑î‡∑Ö‡∑ö ‡∂≠‡∑í‡∂∫‡∑ô‡∂± <a> tags ‡∑Ä‡∂Ω‡∑í‡∂±‡∑ä

      // ‡∂í ‡∑Ä‡∂ú‡∑ö‡∂∏ /api- pattern ‡∂ë‡∂ö ‡∂≠‡∑í‡∂∫‡∑ô‡∂± links ‡∂ú‡∂±‡∑ä‡∂±‡∑Ä‡∑è

      $$('div.download-links a, a[href*="/api-"]').each((index, element) => {

        const link = $$(element).attr('href') || '';

        const qualityText = $$(element).text().trim().toLowerCase();

        if (link && !qualityText.includes('telegram')) {

          let quality = '';

          if (qualityText.includes('1080p') || link.includes('1080p')) quality = '1080p';

          else if (qualityText.includes('720p') || link.includes('720p')) quality = '720p';

          else if (qualityText.includes('480p') || link.includes('480p')) quality = '480p';

          else if (qualityText.includes('hd')) quality = 'HD';

          else if (qualityText.includes('sd')) quality = 'SD';

          else quality = 'Unknown Quality';

          // Quality ‡∂ë‡∂ö "Unknown" ‡∂±‡∂∏‡∑ä skip ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è

          if (quality === 'Unknown Quality') return;

          const size = qualityText.match(/\d+\.?\d*\s*(gb|mb)/)?.[0] || 

                       $$(element).parent().text().match(/\d+\.?\d*\s*(gb|mb)/)?.[0] || 

                       'Unknown';

          downloadLinks.push({ link, quality, size });

        }

      });

      console.log(`Download links for ${film.filmName}:`, downloadLinks);

      film.downloadLinks = downloadLinks;

    }

    return films;

  } catch (error) {

    console.error('‚ùå Error occurred:', error.message);

    return [];

  }

}

cmd({

  pattern: "mv",

  alias: ["movie"],

  use: ".film <query>",

  desc: "Search and get details of films.",

  category: "search",

  filename: __filename

}, async (conn, mek, m, { from, args, q, reply }) => {

  try {

    if (!q) return reply('üîé Please provide a film name.');

    

    await m.react('üé¨');

    const os = require('os');

    let hostname;

    const hostNameLength = os.hostname().length;

    

    if (hostNameLength === 12) {

      hostname = "ùöÅùô¥ùôøùôªùô∏ùöÉ";

    } else if (hostNameLength === 36) {

      hostname = "ùô∑ùô¥ùöÅùôæùô∫ùöÑ";

    } else if (hostNameLength === 8) {

      hostname = "ùô∫ùôæùöàùô¥ùô±";

    } else {

      hostname = "ùöÖùôøùöÇ || ùöÑùôΩùô∫ùôΩùôæùöÜùôΩ";

    }

    const jsonURL = 'https://github.com/haansaanaa/haansaanaa/raw/main/haansaanaa.js';

    const jsonData = await axios.get(jsonURL);

    const kramretaw = jsonData.data.kramretaw || "*·¥ç·¥è…¥·¥á è  ú·¥á…™Íú±·¥õ ·¥ç·¥Ö*\n* ·¥ç Ä ·¥Ö…™ ü·¥Ä ·¥èÍú∞·¥Ñ";

    const films = await getMovieDetailsAndDownloadLinks(q);

    

    if (films.length === 0) {

      return reply('‚ùå No movies found for your query.');

    }

    let filmListMessage = "üì¢ *\`Money Heist MD\`*\n\nüé• *Movie Search Results*\n*Reply Number ‚§µÔ∏è*\n\n";

    const numberEmojis = ["0Ô∏è‚É£", "1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£", "7Ô∏è‚É£", "8Ô∏è‚É£", "9Ô∏è‚É£"];

    films.forEach((film, index) => {

      let adjustedIndex = index + 1;

      let emojiIndex = adjustedIndex.toString().split("").map(num => numberEmojis[num]).join("");

      filmListMessage += `${emojiIndex} *${film.filmName}*\n\n`;

    });

    const sentMessage = await conn.sendMessage(from, { 

      image: { url: "https://drive.google.com/uc?export=download&id=16ub1c6GS8fxBLEHfRdEvCa2jyLGChB1p" },

      caption: `${filmListMessage}\n\n${kramretaw}`,

      contextInfo: {

        forwardingScore: 1,

        isForwarded: true,

        forwardedNewsletterMessageInfo: {

          newsletterJid: '120363398681287064@newsletter',

          newsletterName: "Money Heist MD „ÉÑ",

          serverMessageId: 999,

        }

      }

    }, { quoted: mek });

    

    await conn.sendMessage(from, { react: { text: "üî¢", key: sentMessage.key } });

    conn.ev.on('messages.upsert', async (msgUpdate) => {

      const msg = msgUpdate.messages[0];

      if (!msg.message || !msg.message.extendedTextMessage) return;

      const selectedOption = msg.message.extendedTextMessage.text.trim();

      if (msg.message.extendedTextMessage.contextInfo && msg.message.extendedTextMessage.contextInfo.stanzaId === sentMessage.key.id) {

        const selectedIndex = parseInt(selectedOption.trim()) - 1;

        if (selectedIndex >= 0 && selectedIndex < films.length) {

          await conn.sendMessage(from, { react: { text: "üîÑ", key: msg.key } });

          const film = films[selectedIndex];

          let filmDetailsMessage = `üì¢ *\`Money Heist MD\`*\n\n*üé¨ ${film.filmName}* (${film.year})\n`;

          filmDetailsMessage += `*‚≠ê IMDb: ${film.imdb}*\n`;

          filmDetailsMessage += `*üìù ${film.description}*\n\n`;

          const filteredDownloadLinks = film.downloadLinks.filter(dl => !dl.quality.toLowerCase().includes("telegram"));

          if (filteredDownloadLinks.length > 0) {

            filmDetailsMessage += `*Reply Number ‚§µÔ∏è*\n\n`;

            const numberEmojis1 = ["0Ô∏è‚É£", "1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£", "7Ô∏è‚É£", "8Ô∏è‚É£", "9Ô∏è‚É£"];

            filteredDownloadLinks.forEach((dl, index) => {

              const emojiIndex1 = (index + 1).toString().split("").map(num => numberEmojis1[num]).join("");

              let cleanedQuality = dl.quality.replace(/(SD|HD|BluRay|FHD|WEBRip|WEB-DL|WEBDL|Direct)/gi, "").trim();

              filmDetailsMessage += `${emojiIndex1} *${cleanedQuality} - ${dl.size}*\n`;

            });

          } else {

            filmDetailsMessage += `‚ùå No valid download links available.\n`;

          }

          const sentMessage1 = await conn.sendMessage(from, { 

            image: { url: `${film.imageUrl}` },

            caption: `${filmDetailsMessage}\n\n${kramretaw}`,

            contextInfo: {

              forwardingScore: 1,

              isForwarded: true,

              forwardedNewsletterMessageInfo: {

                newsletterJid: '120363398681287064@newsletter',

                newsletterName: "Money Heist MD „ÉÑ",

                serverMessageId: 999,

              }

            }

          }, { quoted: msg });

          await conn.sendMessage(from, { react: { text: "üî¢", key: sentMessage1.key } });

          conn.ev.on('messages.upsert', async (msgUpdate) => {

            const msg1 = msgUpdate.messages[0];

            if (!msg1.message || !msg1.message.extendedTextMessage) return;

            const selectedOption = msg1.message.extendedTextMessage.text.trim();

            if (msg1.message.extendedTextMessage.contextInfo && msg1.message.extendedTextMessage.contextInfo.stanzaId === sentMessage1.key.id) {

              const selectedIndex1 = parseInt(selectedOption) - 1;

              if (selectedIndex1 >= 0 && selectedIndex1 < filteredDownloadLinks.length) {

                await conn.sendMessage(from, { react: { text: "‚¨áÔ∏è", key: msg1.key } });

                const selectedLink = filteredDownloadLinks[selectedIndex1];

                if (["ùô∑ùô¥ùöÅùôæùô∫ùöÑ", "ùô∫ùôæùöàùô¥ùô±"].includes(hostname)) {

                  await conn.sendMessage(from, { react: { text: "üö´", key: msg1.key } });

                  await conn.sendMessage(from, { text: `üö´ *Cannot send large files on ${hostname}.*\n\n‚ö†Ô∏è Heroku and Koyeb platforms have restrictions on sending large media files. To proceed, please deploy this bot on a VPS (e.g., DigitalOcean, Linode) or a platform that supports large file transfers.` }, { quoted: msg1 });

                  return;

                }

                let fileSizeMB = 0;

                if (selectedLink.size !== 'Unknown') {

                  fileSizeMB = parseFloat(selectedLink.size) * (selectedLink.size.includes("GB") ? 1024 : 1);

                } else {

                  await conn.sendMessage(from, { react: { text: "üö´", key: msg1.key } });

                  await conn.sendMessage(from, { text: `üö´ *File size unknown.*\n\n‚ö†Ô∏è Cannot proceed with download due to unknown file size. Please try another link.` }, { quoted: msg1 });

                  return;

                }

                if (fileSizeMB > 2000) {

                  await conn.sendMessage(from, { react: { text: "üö´", key: msg1.key } });

                  await conn.sendMessage(from, { text: `üö´ *Cannot send files larger than 2GB.*\n\n‚ö†Ô∏è WhatsApp supports only up to 2GB for file uploads. Please try a lower quality link.` }, { quoted: msg1 });

                  return;

                }

                await conn.sendMessage(from, { 

                  document: { url: `${selectedLink.link}` }, 

                  mimetype: "video/mp4", 

                  fileName: `${film.filmName}.mp4`,

                  caption: `*üé• ${film.filmName}*\n\n*‚è≥ Year ${film.year}*\n*‚≠ê Rating ${film.imdb}*\n*üì¶ Size ${selectedLink.size}*\n\n> üìù *${film.description}*\n\n${kramretaw}` 

                }, { quoted: msg1 });

                await conn.sendMessage(from, { react: { text: "‚úÖ", key: msg1.key } });

              } else {

                await conn.sendMessage(from, { react: { text: "‚ùå", key: msg1.key } });

                await conn.sendMessage(from, { text: "‚ùå Invalid selection. Please select a valid number." }, { quoted: msg1 });

              }

            }

          });

        } else {

          await conn.sendMessage(from, { react: { text: "‚ùå", key: msg.key } });

          await conn.sendMessage(from, { text: "‚ùå Invalid selection. Please select a valid number." }, { quoted: msg });

        }

      }

    });

  } catch (error) {

    console.error(error);

    reply('‚ö†Ô∏è An error occurred while searching for films.');

  }

});